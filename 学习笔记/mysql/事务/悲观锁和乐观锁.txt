目录:
    悲观锁
    乐观锁
    使用redis避免超发问题
    
首先要理解java中的多线程并发是怎么运行的:
    在单个进程中,可以同时运行多个线程,这个过程叫做多线程并发.
    并发的执行过程是这样的: 
        cpu对每个线程只执行一小段时间,到时间没执行完该线程,就先把当前线程挂起,切换到另外一个线程执行.
        这样使得多线程看上去好像是同时执行一样,但其实同一时间只执行一个线程.

基于java多线程并发的机制,可能导致超发问题(仅剩1件货物时被多个线程下单,导致库存成负数)

我们可以通过给数据(record)添加锁的方式来避免这类问题:
    有两种锁机制,分别是悲观锁和乐观锁.

    悲观锁:通过数据库加锁的方式实现
        语句: 
            SELECT ...... 
            FROM table 
            WHERE id=1 
            FOR UPDATE;
            // 在查询语句末尾加上for update来加锁
            // innoDB引擎下,加的是行级锁
        这样执行了该语句后,就会阻塞其他事务对该条数据的读写操作.只有当前事务commit之后才会释放锁.
        
        解决超发问题的步骤:
            当前线程查询库存的SQL语句给record加上锁,其他线程的查询库存SQL会被阻塞.
            知道当前线程的事务执行完才会释放锁.
        
        带来的问题:
            性能低.因为会导致线程被阻塞

    乐观锁:
        基于多线程的CAS(Compare And Swap)概念 比较,替换 比较过后没问题再替换.
        但CAS机制会导致ABA问题.(通过新增version字段的方法来解决)
        乐观锁不用给数据库表加锁,是使用 新旧记录对比 的方法来更新数据. 记录(version)未发生变化才能更新数据.
        具体实现:
            1.给表添加version字段.
            2.在更新表前先查询记录(record)
            3.查询确认数据正常后执行更新SQL
                SQL文(以商品下订单为例):
                    UPDATE table
                    SET 
                        stock = stock - 1,  // 库存递减
                        version = version + 1   // version递增
                    WHERE
                        id = #{goods.id},
                        version = #{goods.version}  // 若先前查询的旧version和当前新version不一致,则更新不了.

        原理:
            只要记录(record)发生改变,version就会递增.那么在执行更新操作时就能通过version对比察觉记录是否被改变
        
        带来的问题:
            更新失败率过高
        如何解决:
            使用重入机制.接用while/for循环,重复执行,使用时间限制或重入次数限制来限制重入次数.当没有失败成功执行完时退出循环

        为什么要添加version字段?直接在WHERE后边比较 新旧库存 不行吗?
            这会导致ABA问题.
            什么是ABA问题: 
                比如小王把一杯水放在桌子上走开了,这时小明过来喝掉了,又续了一杯.结果小王回来喝水时并不能发现已经不是之前那杯水了.
                    (喝掉再续杯 可以看作是 下订单后又退单)
            感觉即使有ABA问题也无所谓啊......反正能买到货就行了啊

使用redis可以不用加锁就能避免超发问题:
    redis执行lua脚本具有原子性,借用lua脚本执行事务,根本无须加锁,而且速度贼快!
    而用java代码执行事务,则需要我们通过悲观锁或乐观锁的方式来保证事务的原子性.

    怎么做:
        1.把商品表和订单表保存在redis中.使用lua脚本进行查询库存,更新库存,创建订单等操作.
        2.通过Spring定时任务,每天半夜将redis中的数据保存至数据库并刷新redis缓存.

    先不介绍,以后抽时间完善.
    具体执行步骤上网查或者参阅<深入浅出springboot>
    
    关于Spring定时任务:
        1.启用定时任务:
            在配置类上添加@EnableScheduling启用Spring定时任务
        2.实现TaskService接口,重写purchaseTask()方法,并在该方法上添加@Scheduled注解来指定执行任务间隔
        3.注意定时任务实现类上添加@Service注解来装载bean