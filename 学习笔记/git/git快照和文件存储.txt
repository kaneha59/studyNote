git在正确的抽象层次上处理存储空间压缩，
使得程序比上代（如svn）和同时代（如bzr）的VCS大为简化。

之前的VCS从节省空间出发，想当然地把delta作为基础数据结构。
这样的最大问题（远不是唯一问题）是：delta设计时没有考虑到的修改方式就无法表达。
例如，svn早期版本及更早的VCS不能记录文件rename/copy，
所以只要重命名文件，列出历史时重命名之前的历史就显示不出来。

git的存储层（plumbing layer）提供的接口里，每个commit都记录完整的目录树。
存储空间压缩问题完全在存储层内部解决：
1. 逻辑上，存储层是一个CAS（Content-Addressable Storage）。
这意味着在一个commit中，所有没改变的文件和目录都不额外占用存储空间。
进一步，两个目录中内容相同的文件也只占用一份存储空间；
甚至，两个文件的任意两个历史版本只要内容相同，就只占用一份存储空间。这是基于delta的VCS做不到的。
2. 而对于同一个文件的历史版本的压缩，git的做法是把全部文件的历史版本统一处理，
把文件间相同的片段进行压缩。这意味着两个不相干的文件中相同的片段也可以被压缩。
这是基于delta的VCS做不到的。